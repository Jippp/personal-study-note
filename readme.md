# 微前端隔离的几种方案

## 空白iframe解决隔离问题

通过创建空白的iframe来为子应用提供执行环境

1. 主应用中通过请求获取子应用列表，动态创建导航
2. 根据导航切换子应用，切换时跨域请求子应用的JS文本内容并缓存
3. 子应用的JS在iframe中通过script标签进行隔离执行

`src="about:blank"`会让当前iframe继承父级上下文的源，即遵守同源策略

```js
window.document.domain = window.parent.document.domain // true
```
但是子应用使用`history`API时如果新的URL和当前URL不同源就会报错

## 同源iframe解决history异常

1. 在主应用中通过请求获取子应用列表，动态创建导航
2. 根据导航切换子应用，切换时跨域请求子应用的JS文本内容并缓存
3. 切换子应用的时加载一个同源的iframe，在iframe中通过script标签隔离执行子应用的js

简单来说就是在iframe基础上，引入的是同源的空白iframe，然后再在该iframe中执行子应用的js。但是这样会加载一个同源空白iframe，可能有性能损耗。

## 快照隔离

iframe隔离依赖了浏览器内部Context的隔离，隔离是比较彻底的，某些场景可能不是很合适，所以可以通过纯JS来隔离。

快照隔离的本质：添加一个中间快照层，初始化子应用时记录主应用的window快照，运行子应用时是在这个window快照上的，等失活时，记录本次运行操作的内容(变量、属性等)，然后将window恢复。等下一次激活时，从缓存中拿到值来恢复状态。

可以看到这种方案**只能满足同一时刻运行一个子应用**。

大致过程如下：
1. 通过请求获取到子应用列表信息，动态创建导航
2. 根据导航切换子应用，获取到子应用的JS文本并缓存
3. 激活某个子应用时，其他的子应用要失活，保证同一时间只有一个子应用在激活状态
4. 运行子应用前，从缓存中找到该子应用上一次运行记录的信息，和主应用的window进行合并，以此来恢复子应用的状态
5. 失活时将当前的window和主应用window对比，找到本次运行有变动的内容并记录。之后恢复主应用的window，防止干扰其他子应用的运行。


