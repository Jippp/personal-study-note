---
private: true
date: 2025-03-18
title: 依赖治理
---

## 问题背景

npm的问题

- 低版本的嵌套依赖问题

yarn的问题

- 虽然解决了嵌套依赖，但是没有解决幽灵依赖的问题

pnpm的优化

- 扁平化管理依赖，解决了大部分幽灵依赖，但是对于旧库的幽灵依赖还是无法修改(改动影响太大 第三方库也不一定有人维护了)

幽灵依赖

- 在项目中能直接使用到未在package中安装的依赖

多余依赖

- 可以通过自定义脚本来判断依赖是否被使用

重复依赖

- monorepo项目中，既在A有，也在B有，可以提升到根目录下，通过peerDependencies来引入
- 也是自定义脚本来判断依赖是否被使用

锁文件

安装依赖时会根据`lock`文件来安装对应版本的依赖。

版本号：
- `~`开头：会匹配最新的小版本
- `^`开头：会匹配最新的次版本以及小版本
- `*`：匹配最新版本

1. 能保证版本的确定性以及一致性
  每次安装依赖时版本是固定的，开发以及cicd中使用同一个lock文件，能保证依赖树一致性，从而确保正确。
2. 提高安装速度：记录了版本和来源，不需要解析依赖关系和版本信息

正确使用？

1. 首次提交，通过lock可以避免协作开发时依赖不一致
2. 更新依赖后，一定要提交lock
3. npm ci 或者 yarn i --frozen-lockfile：会完全按照lock文件来安装 并忽略package的版本范围
4. lock文件有冲突，应删除本地的，重新install生成lock文件

